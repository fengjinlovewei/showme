{"parsed":{"_path":"/async-await","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Async Await","description":"1.明确概念\nasync函数就是generator函数的语法糖。\nasync函数，就是将generator函数的*换成async，将yield替换成await。\n2.async函数对generator的改进\n(1) async内置执行器，不需要使用next()手动执行。\n(2) await关键字后面的表达式返回的值可以是任何类型，只不过在解释器处理时，不是Promise类型的要转化成Promise.resolve(value)\nyield关键字后面的表达式返回的值可以是任何类型。\n(3) async函数返回值是Promise。返回非Promise时，async函数会把它包装成Promise返回。(Promise.resolve(value))\n3.作用\n异步编程的终极解决方案。","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1.明确概念"}]},{"type":"text","value":"\nasync函数就是generator函数的语法糖。\nasync函数，就是将generator函数的*换成async，将yield替换成await。\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2.async函数对generator的改进"}]},{"type":"text","value":"\n(1) async内置执行器，不需要使用next()手动执行。\n(2) await关键字后面的表达式返回的值可以是任何类型，只不过在解释器处理时，不是Promise类型的要转化成Promise.resolve(value)\nyield关键字后面的表达式返回的值可以是任何类型。\n(3) async函数返回值是Promise。返回非Promise时，async函数会把它包装成Promise返回。(Promise.resolve(value))\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3.作用"}]},{"type":"text","value":"\n异步编程的终极解决方案。"}]},{"type":"element","tag":"h5","props":{"id":"如果想彻底搞懂以上概念需要使用function-yield手动去实现asyncawait但是实现之前需要知道asyncawait和function-yield怎么使用"},"children":[{"type":"text","value":"如果想彻底搞懂以上概念，需要使用function* /yield手动去实现async/await，但是实现之前，需要知道async/await和function* /yield怎么使用。"}]},{"type":"element","tag":"h5","props":{"id":"一使用asyncawait"},"children":[{"type":"text","value":"一、使用async/await"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"这个函数贯穿始终"}]}]},{"type":"element","tag":"pre","props":{"code":"//模拟异步请求\nconst getTime = function (time, bool){\n  return new Promise(function (resolve, reject){\n    setTimeout(()=> {\n      bool ? resolve(time) : reject(`${time}报错了`)\n    }, time)\n  });\n};\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//模拟异步请求\nconst getTime = function (time, bool){\n  return new Promise(function (resolve, reject){\n    setTimeout(()=> {\n      bool ? resolve(time) : reject(`${time}报错了`)\n    }, time)\n  });\n};\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.async函数声明语句"}]},{"type":"element","tag":"pre","props":{"code":"async function getData(){\n  return await getTime(2000, true)\n}\ngetData()\n.then(res => {\n  console.log(res) //2000\n})\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"async function getData(){\n  return await getTime(2000, true)\n}\ngetData()\n.then(res => {\n  console.log(res) //2000\n})\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"2.async函数表达式语句"}]},{"type":"element","tag":"pre","props":{"code":"const getData = async function (){\n  return await getTime(2000, true)\n}\ngetData()\n.then(res => {\n  console.log(res) //2000\n})\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const getData = async function (){\n  return await getTime(2000, true)\n}\ngetData()\n.then(res => {\n  console.log(res) //2000\n})\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"3.IIFE使用async"}]},{"type":"element","tag":"pre","props":{"code":"( async () => {\n  const data = await getTime(2000, true)\n  console.log(data) //2000\n})();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"( async () => {\n  const data = await getTime(2000, true)\n  console.log(data) //2000\n})();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"4.在对象上使用async"}]},{"type":"element","tag":"pre","props":{"code":"const obj1 = {\n  async getData(){\n    return await getTime(2000, true)\n  }\n};\nclass obj2 {\n  async getData(){\n    return await getTime(1000, true)\n  }\n}\n( async () => {\n  const data1 = await obj1.getData();\n  const data2 = await new obj2().getData();\n  console.log(data1) //2000\n  console.log(data2) //1000\n})();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const obj1 = {\n  async getData(){\n    return await getTime(2000, true)\n  }\n};\nclass obj2 {\n  async getData(){\n    return await getTime(1000, true)\n  }\n}\n( async () => {\n  const data1 = await obj1.getData();\n  const data2 = await new obj2().getData();\n  console.log(data1) //2000\n  console.log(data2) //1000\n})();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5.async函数内，手动捕获错误&处理"}]},{"type":"element","tag":"pre","props":{"code":"async function getData(){\n  return await getTime(2000, false)\n}\n( async () => {\n  try{\n    const data= await getData();\n    console.log(data)\n  } catch (err) {\n    console.log(err) //2000报错了\n  }\n})();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"async function getData(){\n  return await getTime(2000, false)\n}\n( async () => {\n  try{\n    const data= await getData();\n    console.log(data)\n  } catch (err) {\n    console.log(err) //2000报错了\n  }\n})();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"6.async内使用同步"}]},{"type":"element","tag":"pre","props":{"code":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n\n( async () => {\n  console.time('title')\n  const data1 = await getData(1000);\n  const data2 = await getData(2000);\n  console.log(data1) //1000\n  console.log(data2) //2000\n  console.timeEnd('title')\n  // title: 7015.192ms\n})();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n\n( async () => {\n  console.time('title')\n  const data1 = await getData(1000);\n  const data2 = await getData(2000);\n  console.log(data1) //1000\n  console.log(data2) //2000\n  console.timeEnd('title')\n  // title: 7015.192ms\n})();\n"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结论：两个await同步执行，整个函数运行完成7秒多"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"7.async内使用异步"}]},{"type":"element","tag":"pre","props":{"code":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n( async () => {\n  console.time('title')\n  const data1 = getData(1000);\n  const data2 = getData(2000);\n  //请求全部发出后，await需要等待pramise状态，\n  //如果pramise是pending状态需要继续等待，\n  //如果不是pending,\n  //为resolve时，其参数作为 await 表达式的值\n  //为rejected时，await 表达式会将其参数当做异常抛出。\n  const _data1 = await data1;\n  const _data2 = await data2;\n  console.log(_data1) //1000\n  console.log(_data2) //2000\n  console.timeEnd('title')\n  //title: 4015.644ms\n})();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n( async () => {\n  console.time('title')\n  const data1 = getData(1000);\n  const data2 = getData(2000);\n  //请求全部发出后，await需要等待pramise状态，\n  //如果pramise是pending状态需要继续等待，\n  //如果不是pending,\n  //为resolve时，其参数作为 await 表达式的值\n  //为rejected时，await 表达式会将其参数当做异常抛出。\n  const _data1 = await data1;\n  const _data2 = await data2;\n  console.log(_data1) //1000\n  console.log(_data2) //2000\n  console.timeEnd('title')\n  //title: 4015.644ms\n})();\n"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结论：两个await异步执行，整个函数运行完成4秒多。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"使用Promise.all实现异步"}]}]},{"type":"element","tag":"pre","props":{"code":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n( async () => {\n  console.time('title')\n  const [data1, data2] = await Promise.all([\n    getData(1000),\n    getData(2000)\n  ])\n  console.log(data1) //1000\n  console.log(data2) //2000\n  console.timeEnd('title')\n  //title: 4018.707ms\n})();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n( async () => {\n  console.time('title')\n  const [data1, data2] = await Promise.all([\n    getData(1000),\n    getData(2000)\n  ])\n  console.log(data1) //1000\n  console.log(data2) //2000\n  console.timeEnd('title')\n  //title: 4018.707ms\n})();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在for循环中实现异步"}]}]},{"type":"element","tag":"pre","props":{"code":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n( async () => {\n  console.time('title')\n  let promise = [1000, 2000]\n  promise = promise.map(item =>getData(item))\n  for(const i of promise){\n    let data = await i\n    console.log(data)\n    //1000\n    //2000\n  }\n  console.timeEnd('title')\n  //title: 4005.523ms\n})();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"async function getData(time){\n  await getTime(2000, true) //延迟2秒\n  return await getTime(time, true)\n}\n( async () => {\n  console.time('title')\n  let promise = [1000, 2000]\n  promise = promise.map(item =>getData(item))\n  for(const i of promise){\n    let data = await i\n    console.log(data)\n    //1000\n    //2000\n  }\n  console.timeEnd('title')\n  //title: 4005.523ms\n})();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"#####二、使用function* / yield\n"},{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/liumingwang/p/10216073.html","rel":["nofollow"]},"children":[{"type":"text","value":"关于function* / yield的基础方法介绍的文章"}]},{"type":"element","tag":"a","props":{"href":"https://www.jianshu.com/p/464c5aeabc40","rel":["nofollow"]},"children":[{"type":"text","value":"文章部分介绍了function* / yield"}]},{"type":"text","value":"\n基础方法需要了解一下，不赘述了"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"####三、使用function* / yield 实现 async/await 函数"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实现目标：\n①内部支持异步代码的同步化\n②函数返回值必须是一个Promise\n③yield后的值必须是Promise，不是的会被转化成Promise\n④函数体内如果使用try/catch语句，能够捕获错误，且不影响函数内以下代码的执行。\n⑤函数体内没有使用try/catch包裹的语句如果报错，需要在函数返回的Promise对象的catch捕获，且函数内代码执行结束。\n⑥函数的参数要正常使用，且执行内部的this需要指向定义时的对象。\n⑦如果执行函数内部return 后是Promise，直接取这个Promise的状态和值为己用，如果结果值依然是Promise，则继续反复，直到拿到一个非Promise值。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"_async.js"}]},{"type":"element","tag":"pre","props":{"code":"/**\n* 传入需要使用async的函数\n* @param {function} fn\n* @return {function}\n*/\nfunction _async (fn) {\n  return function (...arg) {\n    //实现目标6\n    let gen = fn.apply(this, arg)\n    //实现目标2\n    return new Promise(function(resolve, reject){\n      _iterator(gen, resolve, reject)\n    })\n  }\n}\n//验证是否是Promise\nfunction isPromise(value){\n  let s = Object.prototype.toString\n  return s.call(value) === '[object Promise]'\n}\n/**\n* @param {generator} gen 迭代对象\n* @param {resolve} resolve Promise的成功回调\n* @param {reject} reject Promise的失败回调\n* @param {any} val 迭代时next需要的参数\n* @param {any} err 迭代时产生的错误对象\n*/\nfunction _iterator(gen, resolve, reject, val, err){\n  try{\n    //gen.throw(err) 实现目标4\n    var {value, done} = err ? gen.throw(err) : gen.next(val)\n  }catch(err){\n    //实现目标5\n    return reject(err)\n  }\n  //实现目标7\n  //这个功能Promise内部会帮我处理好\n  if(done) { return resolve(value) }\n  //实现目标3\n  if(!isPromise(value)){\n    value = Promise.resolve(value)\n  }\n  ////实现目标1\n  value\n  .then( res => {\n    _iterator(gen, resolve, reject, res)\n  }, err => {\n    _iterator(gen, resolve, reject, null, err)\n  })\n}\n\nmodule.exports = _async\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/**\n* 传入需要使用async的函数\n* @param {function} fn\n* @return {function}\n*/\nfunction _async (fn) {\n  return function (...arg) {\n    //实现目标6\n    let gen = fn.apply(this, arg)\n    //实现目标2\n    return new Promise(function(resolve, reject){\n      _iterator(gen, resolve, reject)\n    })\n  }\n}\n//验证是否是Promise\nfunction isPromise(value){\n  let s = Object.prototype.toString\n  return s.call(value) === '[object Promise]'\n}\n/**\n* @param {generator} gen 迭代对象\n* @param {resolve} resolve Promise的成功回调\n* @param {reject} reject Promise的失败回调\n* @param {any} val 迭代时next需要的参数\n* @param {any} err 迭代时产生的错误对象\n*/\nfunction _iterator(gen, resolve, reject, val, err){\n  try{\n    //gen.throw(err) 实现目标4\n    var {value, done} = err ? gen.throw(err) : gen.next(val)\n  }catch(err){\n    //实现目标5\n    return reject(err)\n  }\n  //实现目标7\n  //这个功能Promise内部会帮我处理好\n  if(done) { return resolve(value) }\n  //实现目标3\n  if(!isPromise(value)){\n    value = Promise.resolve(value)\n  }\n  ////实现目标1\n  value\n  .then( res => {\n    _iterator(gen, resolve, reject, res)\n  }, err => {\n    _iterator(gen, resolve, reject, null, err)\n  })\n}\n\nmodule.exports = _async\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用"}]},{"type":"element","tag":"pre","props":{"code":"const _async = require('./_async')\n//模拟异步请求\nconst getTime = function (time, bool){\n  return new Promise(function (resolve, reject){\n    setTimeout(()=> {\n      bool ? resolve(time) : reject(`${time}报错了`)\n    }, time)\n  });\n};\n\n\n//模拟vue的methods\nlet methods =  {\n  name: 'Vue',\n  getPromise: _async(function* (a, b, c){\n    console.log(this.name) //查看当前的活动对象\n    console.log(a,b,c) //查看当前参数\n    var f1 = yield getTime(1000, true);\n    console.log(f1);\n    var f2 = yield getTime(2000, true);\n    console.log(f2);\n    var f3 = yield 200;\n    console.log(f3);\n        //查看内部的错误捕获\n    try{\n      var f4 = yield getTime(1000, false);\n      console.log(f4);\n    }catch(err){\n      console.log(err)\n    }\n    //打开这条注释，查看没有try的报错处理\n    //throw new Error('函数内报错，')\n    console.timeEnd('move')\n    return getTime(2000, false)\n  })\n}\nconsole.time('move')\n\nmethods.getPromise(9,8,7)\n.then(res => {\n  console.log(res)\n}).catch(err =>{\n  console.log(err)\n})\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const _async = require('./_async')\n//模拟异步请求\nconst getTime = function (time, bool){\n  return new Promise(function (resolve, reject){\n    setTimeout(()=> {\n      bool ? resolve(time) : reject(`${time}报错了`)\n    }, time)\n  });\n};\n\n\n//模拟vue的methods\nlet methods =  {\n  name: 'Vue',\n  getPromise: _async(function* (a, b, c){\n    console.log(this.name) //查看当前的活动对象\n    console.log(a,b,c) //查看当前参数\n    var f1 = yield getTime(1000, true);\n    console.log(f1);\n    var f2 = yield getTime(2000, true);\n    console.log(f2);\n    var f3 = yield 200;\n    console.log(f3);\n        //查看内部的错误捕获\n    try{\n      var f4 = yield getTime(1000, false);\n      console.log(f4);\n    }catch(err){\n      console.log(err)\n    }\n    //打开这条注释，查看没有try的报错处理\n    //throw new Error('函数内报错，')\n    console.timeEnd('move')\n    return getTime(2000, false)\n  })\n}\nconsole.time('move')\n\nmethods.getPromise(9,8,7)\n.then(res => {\n  console.log(res)\n}).catch(err =>{\n  console.log(err)\n})\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"大佬略，新手可以参考一下，反正我是写完之后再看function* / yield 和 async/await ，觉得很通透。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:async-await.md","_source":"content","_file":"async-await.md","_extension":"md"},"hash":"ZcshK6GOhU"}